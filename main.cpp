//-----------------------------------------------------------------------------
#include <math.h>
#include "printing.h"
#include "functions.h"
//-----------------------------------------------------------------------------
using namespace std;
//-----------------------------------------------------------------------------
const int STEP = 2; // Изнчальное кол-во шагов для вычисления интеграла
const int NMAX = 20; // Ограничение на количество итераций (2^NMAX * STEP)
//-----------------------------------------------------------------------------
typedef double (*TPF)(const double &); // Функция для интегрирования
typedef double (*TPI)(const double &, const double &); // Точный интеграл
//-----------------------------------------------------------------------------
// Метод прямоугольников для вычисления значения интеграла
//-----------------------------------------------------------------------------
double IntRect(TPF f, double a, double b, double EPS, int &n)
{
	long int step_count = STEP; // Количество разбиений
	double s = 0, sd;           // Приближенное значение интеграла
	double r;                   // Оценочное значение погрешности
	do {
		++n;
		sd = s;
		s = 0;
		double h = (b - a) / step_count;
		for (long int i = 1; i <= step_count; ++i) {
			double x = a + (i-1)*h + h/2;
			s += f(x);
		}
		s *= h;
		r = fabs(s - sd) / 3; // Оцениваем погрешность
		step_count *= 2;
	} while (r >= EPS/10 && n < NMAX);
	n = step_count/2; // Передаем кол-во итераций
	return s;
}
//-----------------------------------------------------------------------------
// Метод трапеций для вычисления значения интеграла
//-----------------------------------------------------------------------------
double IntTrap(TPF f, double a, double b, double EPS, int &n)
{
	int step_count = STEP;
	double s = 0, sd = 0, r;
	do {
		++n;
		sd = s;
		s = f(a);
		double h = (b - a) / step_count;
		for (int i = 1; i < step_count; ++i) {
			double x = a + i*h;
			s += f(x);
		}
		s += f(a + step_count*h);
		s *= (h);
		r = fabs(s - sd) / 3; // Оцениваем погрешность
		step_count *= 2;
	} while (r >= EPS/10 && n < NMAX);
	n = step_count/2; // Передаем кол-во итераций
	return s;
}
//-----------------------------------------------------------------------------
int main()
{
	double a, b, eps;     // Пределы интегрирования (a, b) и погрешность
	InputData(a, b, eps); // Ввводим необходимые данные
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	I_print  res[4];                        // Массив данных для вывода
	TPF function[4] = {f1, f2, f3, f4};     // Интегрируемые функции
	TPI integral[4] = {fi1, fi2, fi3, fi4}; // Функции точного интеграла
	char * title[4] = {(char*)"y=x \0", (char*)"y=sin(22x)\0",
	                   (char*)"y=x^4 \0", (char*)"y=arctg(x)\0"};
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for (int i = 0; i < 4; ++i) { // Интегрируем 4-ре функции IntRect-ом
		int n = 0;
		res[i].i_sum = IntRect(function[i], a, b, eps, n);
		res[i].i_toch = integral[i](a, b);
		res[i].n = n;
		res[i].name = title[i];
	}
	PrintTabl(res, 4); // Форматированный вывод данных
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for (int i = 0; i < 4; ++i) { // Интегрируем 4-ре функции IntTrap-ом
		int n = 0;
		res[i].i_sum = IntTrap(function[i], a, b, eps, n);
		res[i].i_toch = integral[i](a, b);
		res[i].n = n;
		res[i].name = title[i];
	}
	PrintTabl(res, 4); // Форматированный вывод данных
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	return 0;
}
//-----------------------------------------------------------------------------